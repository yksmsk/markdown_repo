# デザインパターンの話

開発を行っていると少なからず耳にする「デザインパターン」
なんとなーく聞いたことあるけど、実際に深く調べたことがなかったので、一から調査してみた。

## 今日の目的

* デザインパターンについて最低限の知識を身につける
* デザインパターンのメリットを知る

### 前置き

そもそも、[デザインパターン][wiki][^1]ご存知ですか？

歴史的な背景を紐解くと、1990年代に出版された『オブジェクト指向における再利用のためのデザインパターン』といった書籍がある。

この本ではGoF(Gang of Four)のデザインパターンとして23のパターンが紹介されている。
プログラマの共通言語的に使われるものなので1度は読んでおくべきかもしれない。

ただし、少し調べてわかったことがある。
上記の書籍は、現代のプログラミングには当てはまらない部分も多々存在する。
以下、ネットの反応

* オブジェクト指向が未成熟な時代に出版されたもの
* 列挙されたパターンに根拠がない
* 古典的な知識を今更知っても仕方ない

などといった反応が散見される。
言われてみれば確かに、なるほどと思ってしまう意見である。

特に、「オブジェクト言語が未成熟な時代」にまとめられた知識であるため、色々と不自由だったために考案されたものが多くある。
→言語のバージョンが上がったことで、標準機能として搭載されたものもある

### 私見

個人的な意見というか、考え方であるが。。。
先人達の知恵と工夫の積み重ねによって現在の技術が存在する訳なので古い知識であろうとも、先人達が残した遺産にあやかれるのであればありがたくあやかっておけばいいじゃない！と思うのです。

今でもレガシーなシステムは確かに存在するので。
目にする機会はゼロではないと思われる。

<u>時間とお金に余裕のある人</u>はきちんと、一から勉強をすれば良いと思う。

が、目紛しく移りゆく現代に生きる我々には先人の知恵を一から辿るには時間が圧倒的に足りない。~~**(言い訳)**~~

### 本題

つらつらと述べたが、言いたいこととしては、美味しいとこだけさらって、
さくっと知識を身に着けたい。

## GoFのデザインパターン

基本的なことだけご紹介
パターンを大別すると以下の3パターン

1. オブジェクトの生成に関するパターン
2. プログラムの構造に関するパターン
3. オブジェクトの振舞に関するパターン

#### GoFのデザインパターン一覧

| 種別   | パターン                    | 使い方  |
| ---- | ----------------------- | ---- |
| 1.生成 | Abstract Factory        |      |
|      | Builder                 |      |
|      | Factory Method          |      |
|      | Prototype               |      |
|      | Singleton               |      |
| 2.構造 | Adapter                 |      |
|      | Bridge                  |      |
|      | Composite               |      |
|      | Decorator               |      |
|      | Facade                  |      |
|      | Flyweight               |      |
|      | Proxy                   |      |
| 3.振舞 | Chain of Responsibility |      |
|      | Command                 |      |
|      | Interpreter             |      |
|      | Iterator                |      |
|      | Mediator                |      |
|      | Memento                 |      |
|      | Observer                |      |
|      | State                   |      |
|      | Strategy                |      |
|      | Template Method         |      |
|      | Visitor                 |      |

※それぞれのパターンの詳細については、時間がなかったため割愛

## デザインパターンのメリット

さて、デザインパターンを利用するメリットを考えてみましょう。

個人的に意味があるなと思うことは、

* 開発スピードが向上する
  - 情報伝達が容易に
  - 解析が容易に


* 保守性が向上する
  - 機能追加・修正が容易に


* プログラムの構造設計ができる様になる
  - アプリケーションの構造設計につながっていく

デザインパターンとは、「よくある問題をうまく解決・対処するための設計」なんて言われている。
再利用性を高くすることで、玄人だけでなく初心者であっても素敵なプログラミングが可能になる。

## Javaで使えるデザインパターン

Javaの開発で避けては通れ(ないことも)ないのが、マルチスレッドプログラミング。
今回はそんなマルチスレッドプログラミングで起こりやすい問題を解決~~できるかもしれない~~するデザインパターンをご紹介。

#### Guarded Suspension / Balking

条件を満たさないときにスレッドを待機させる。または処理を行わない。
マルチスレッドは非同期で動作するため、不用意な状態で処理が実行されることを防げる。

```java
// 状態フラグ
private isBusy = false;

// 実行メソッド
public void execute(){
    synchronized(this){
        if(isBusy){
            wait(); // falseになるまで待機する場合はGuarded Suspensionパターン
            return; // すぐにreturnする場合はBalkingパターン
        }
      	// do something.
      	isBusy = false;
    }
}
```



#### Woker Thread

ワーカースレッドと呼ばれる専用のスレッドを起動しておき、タスクがあれば順次処理を実行する。
ファイルやQueueの監視に使われる。

```java
/** 仕事を与えるクラス */
public class Client extend Thread{
    private Channel channel;
    :
    public void run() {
        while(true){ //永遠に仕事を与え続ける
            Work work = new Work();
            channel.putWork(work);            
        }
    }
}
/** 仕事の管理クラス */
public class Channel {
    private Queue<Work> workQueue = new Queue<>();
    /** 仕事をQueueに保持する */
    public void putWork(Work work) {
        workQueue.add(work);
    }
    /** 仕事をQueueから取得する */
    public Work getWork() {
        return workQueue.poll();
    }
}
/** 仕事の実行クラス */
public class WorkerThread extend Thread {
    private Channel channel;
    :
    public void run() {
        while(true) {                      // 永遠に働き続ける
            Work work = channel.getWork(); // 仕事を取りに行く
            work.execute();                // 仕事の実行
        }
    }
}
```



#### Two-Phase Termination

スレッドの処理を、メイン処理と終了処理に分けてスレッドを安全に終了するためのパターン。
スレッド内に終了要求するメソッドを用意し、終了用のフラグの更新と処理割り込みメソッドinterrupt()を呼ぶ。
終了要求を受けたスレッドは安全に終了できるタイミングで終了処理を開始する。

```Java
// 終了要求が出されたらtrue
private volatile boolean shutdownRequested = false;
// 終了要求
public void shutdownRequest() {
    shutdownRequested = true;
    interrupt();
}
// 動作
public final void run() {
    try {
        while (!shutdownRequested) {
            // doWork();
        }
    } catch (InterruptedException e) {
    } finally {
        // doShutdown();
    }
}
```



## まとめ
デザインパターンについてのお話でした。
デザインパターンの知識的な部分から技術的な部分のサワリを紹介した。

デザインパターンはやりたいことに対してテンプレート的な考えで使用できるため、一から自分で考える必要がなくなり、工数の圧縮や削減に役立つ可能性がある。

ただし、注意が必要だと思われるのが、デザインパターンが「絶対的な解法」ではなく、あくまでも解決の一手法だということ。
思考停止気味にデザインパターンを用いることで、却ってイケテナイ設計になったり、余計な工数を費やすことになるかもしれない。

選択肢の一つとして選べる、または考え方のベースにして応用できることが大事。
クラス設計〜製造工程において、力を発揮するであろうデザインパターンだが、1つ知っていれば良いというものではないので、色々な引き出しを持つことが大切である。



### アプリGrとしての取組み

デザインパターンについて知ることは、製造に携わる人ならば知っておいて損のない知識だと思う。また、設計をメインに担当する人であっても、頭に入れておけば、システムの構造から使った方が良いパターンが見えるため製造の担当者と話がしやすくなると考えられる。

実際のシステムで、どんなときにどんなパターンを使ったか(または、検討したか)をまとめて、使用例から逆引きできる辞書みたいなものを作れると、皆が嬉しく慣れると思う。

[wiki]:https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)

[^1]: ソフトウェア開発におけるデザインパターンとは、過去のソフトウェア設計者が発見し編み出した設計ノウハウを蓄積し、名前をつけ、再利用しやすいように特定の規約に従ってカタログ化したものである。